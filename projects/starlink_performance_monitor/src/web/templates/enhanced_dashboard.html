{% extends "base.html" %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-4 border-bottom">
    <h1 class="h2 page-heading">{{ t.dashboard }}</h1>
    <div class="btn-toolbar mb-2 mb-md-0">
        <div class="btn-group me-2">
            <button type="button" class="btn btn-sm btn-outline-secondary" id="refreshBtn">
                <i class="fas fa-sync-alt"></i> {{ t.refresh }}
            </button>
            <button type="button" class="btn btn-sm btn-outline-primary" id="autoRefreshBtn" data-active="true">
                <i class="fas fa-pause"></i> {{ t.auto_refresh }}
            </button>
        </div>
        <div class="dropdown">
            <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" id="timeRangeDropdown" data-bs-toggle="dropdown">
                {{ t.last_24_hours }}
            </button>
            <ul class="dropdown-menu" id="timeRangeMenu">
                <li><a class="dropdown-item" href="#" data-hours="1">{{ t.last_1_hour }}</a></li>
                <li><a class="dropdown-item" href="#" data-hours="6">{{ t.last_6_hours }}</a></li>
                <li><a class="dropdown-item" href="#" data-hours="12">{{ t.last_12_hours }}</a></li>
                <li><a class="dropdown-item active" href="#" data-hours="24">{{ t.last_24_hours }}</a></li>
                <li><a class="dropdown-item" href="#" data-hours="168">{{ t.last_7_days }}</a></li>
            </ul>
        </div>
    </div>
</div>

<!-- Status Indicator -->
<div class="row mb-4">
    <div class="col-12">
        <div class="alert alert-info d-flex align-items-center rounded-pill" role="alert" id="statusIndicator">
            <i class="fas fa-info-circle me-2 ms-3"></i>
            <div id="statusMessage">{{ t.connecting_data_stream }}</div>
        </div>
    </div>
</div>

<!-- Current Metrics -->
<div class="row mb-4 g-4">
    <div class="col-xl-3 col-md-6">
        <div class="card metric-card h-100 border-0 shadow-sm">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h5 class="card-title mb-0"><i class="fas fa-download text-primary"></i> {{ t.download_speed }}</h5>
                    <div class="badge bg-primary">Mbps</div>
                </div>
                <h2 class="card-text display-6 mb-1" id="downloadSpeed">--</h2>
                <small class="text-muted">Last updated: <span id="downloadTime">--</span></small>
                <div class="progress mt-3" style="height: 8px;">
                    <div class="progress-bar bg-primary" id="downloadProgress" role="progressbar" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-xl-3 col-md-6">
        <div class="card metric-card h-100 border-0 shadow-sm">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h5 class="card-title mb-0"><i class="fas fa-upload text-success"></i> {{ t.upload_speed }}</h5>
                    <div class="badge bg-success">Mbps</div>
                </div>
                <h2 class="card-text display-6 mb-1" id="uploadSpeed">--</h2>
                <small class="text-muted">Last updated: <span id="uploadTime">--</span></small>
                <div class="progress mt-3" style="height: 8px;">
                    <div class="progress-bar bg-success" id="uploadProgress" role="progressbar" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-xl-3 col-md-6">
        <div class="card metric-card h-100 border-0 shadow-sm">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h5 class="card-title mb-0"><i class="fas fa-stopwatch text-info"></i> {{ t.ping }}</h5>
                    <div class="badge bg-info">ms</div>
                </div>
                <h2 class="card-text display-6 mb-1" id="pingTime">--</h2>
                <small class="text-muted">Last updated: <span id="pingTimeTime">--</span></small>
                <div class="progress mt-3" style="height: 8px;">
                    <div class="progress-bar bg-info" id="pingProgress" role="progressbar" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-xl-3 col-md-6">
        <div class="card metric-card h-100 border-0 shadow-sm">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h5 class="card-title mb-0"><i class="fas fa-exclamation-triangle text-warning"></i> {{ t.packet_loss }}</h5>
                    <div class="badge bg-warning">% </div>
                </div>
                <h2 class="card-text display-6 mb-1" id="packetLoss">--</h2>
                <small class="text-muted">Last updated: <span id="packetLossTime">--</span></small>
                <div class="progress mt-3" style="height: 8px;">
                    <div class="progress-bar bg-warning" id="packetLossProgress" role="progressbar" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Charts Section -->
<div class="row g-4 mb-4">
    <div class="col-12">
        <div class="card border-0 shadow-sm">
            <div class="card-header bg-white d-flex justify-content-between align-items-center">
                <h5 class="card-title mb-0">{{ t.performance_history_chart }}</h5>
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-primary" id="chartTypeLine">{{ t.line }}</button>
                    <button type="button" class="btn btn-outline-primary" id="chartTypeBar">{{ t.bar }}</button>
                    <button type="button" class="btn btn-outline-primary" id="chartTypeArea">{{ t.area }}</button>
                </div>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row g-4 mb-4">
    <div class="col-lg-6">
        <div class="card border-0 shadow-sm h-100">
            <div class="card-header bg-white">
                <h5 class="card-title mb-0">{{ t.download_distribution }}</h5>
            </div>
            <div class="card-body">
                <div class="chart-container" style="height: 300px;">
                    <canvas id="downloadDistribution"></canvas>
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-6">
        <div class="card border-0 shadow-sm h-100">
            <div class="card-header bg-white">
                <h5 class="card-title mb-0">{{ t.ping_performance }}</h5>
            </div>
            <div class="card-body">
                <div class="chart-container" style="height: 300px;">
                    <canvas id="pingChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row g-4 mb-4">
    <div class="col-lg-6">
        <div class="card border-0 shadow-sm h-100">
            <div class="card-header bg-white">
                <h5 class="card-title mb-0">{{ t.packet_loss_over_time }}</h5>
            </div>
            <div class="card-body">
                <div class="chart-container" style="height: 300px;">
                    <canvas id="packetLossChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-6">
        <div class="card border-0 shadow-sm h-100">
            <div class="card-header bg-white">
                <h5 class="card-title mb-0">{{ t.performance_summary }}</h5>
            </div>
            <div class="card-body">
                <div class="chart-container" style="height: 300px;">
                    <canvas id="summaryChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Weather Correlation Analysis -->
<div class="row g-4 mb-4">
    <div class="col-12">
        <div class="card border-0 shadow-sm">
            <div class="card-header bg-white">
                <h5 class="card-title mb-0">{{ t.weather_correlation_analysis }}</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>{{ t.weather_parameter }}</th>
                                <th>{{ t.performance_metric }}</th>
                                <th>{{ t.correlation }}</th>
                                <th>{{ t.strength }}</th>
                                <th>{{ t.interpretation }}</th>
                            </tr>
                        </thead>
                        <tbody id="weatherCorrelationTableBody">
                            <tr>
                                <td colspan="5" class="text-center">{{ t.no_correlation_data }}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Alerts Section -->
<div class="row g-4">
    <div class="col-12">
        <div class="card border-0 shadow-sm">
            <div class="card-header bg-white">
                <h5 class="card-title mb-0">{{ t.recent_alerts }}</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>{{ t.time }}</th>
                                <th>{{ t.type }}</th>
                                <th>{{ t.message }}</th>
                                <th>{{ t.value }}</th>
                                <th>{{ t.threshold }}</th>
                            </tr>
                        </thead>
                        <tbody id="alertsTableBody">
                            <tr>
                                <td colspan="5" class="text-center">{{ t.no_recent_alerts }}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<script>
    // Global variables
    let socket = null;
    let autoRefreshInterval = null;
    let currentHours = 24;
    let chartType = 'line';
    let performanceChart = null;
    let pingChart = null;
    let packetLossChart = null;
    let downloadDistributionChart = null;
    let summaryChart = null;
    
    // Initialize WebSocket connection
    function initWebSocket() {
        try {
            // In a real implementation, you would connect to a WebSocket server
            // socket = io();
            // socket.on('connect', function() {
            //     updateStatus('{{ t.connected_data_stream }}', 'success');
            // });
            // socket.on('disconnect', function() {
            //     updateStatus('{{ t.disconnected_data_stream }}', 'warning');
            // });
            // socket.on('metrics_update', function(data) {
            //     updateCurrentMetrics(data);
            // });
            
            // For now, simulate connection
            updateStatus('{{ t.data_stream_simulation }}', 'success');
        } catch (error) {
            console.error('WebSocket connection error:', error);
            updateStatus('{{ t.failed_connect_data_stream }}', 'danger');
        }
    }
    
    // Update status indicator
    function updateStatus(message, type = 'info') {
        const statusIndicator = document.getElementById('statusIndicator');
        const statusMessage = document.getElementById('statusMessage');
        
        // Remove existing classes
        statusIndicator.className = 'alert d-flex align-items-center rounded-pill';
        
        // Add appropriate class based on type
        switch(type) {
            case 'success':
                statusIndicator.classList.add('alert-success');
                statusIndicator.innerHTML = '<i class="fas fa-check-circle me-2 ms-3"></i><div id="statusMessage">' + message + '</div>';
                break;
            case 'warning':
                statusIndicator.classList.add('alert-warning');
                statusIndicator.innerHTML = '<i class="fas fa-exclamation-triangle me-2 ms-3"></i><div id="statusMessage">' + message + '</div>';
                break;
            case 'danger':
                statusIndicator.classList.add('alert-danger');
                statusIndicator.innerHTML = '<i class="fas fa-exclamation-circle me-2 ms-3"></i><div id="statusMessage">' + message + '</div>';
                break;
            default:
                statusIndicator.classList.add('alert-info');
                statusIndicator.innerHTML = '<i class="fas fa-info-circle me-2 ms-3"></i><div id="statusMessage">' + message + '</div>';
        }
    }
    
    // Function to update current metrics
    async function updateCurrentMetrics(data = null) {
        try {
            // If no data provided, fetch from API
            if (!data) {
                const response = await axios.get('/api/current');
                data = response.data.metrics;
            }
            
            if (data) {
                // Update metric values
                document.getElementById('downloadSpeed').textContent = data.download_mbps.toFixed(2);
                document.getElementById('uploadSpeed').textContent = data.upload_mbps.toFixed(2);
                document.getElementById('pingTime').textContent = data.ping_ms.toFixed(2);
                document.getElementById('packetLoss').textContent = data.packet_loss_percent.toFixed(2);
                
                // Update timestamps
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                document.getElementById('downloadTime').textContent = timestamp;
                document.getElementById('uploadTime').textContent = timestamp;
                document.getElementById('pingTimeTime').textContent = timestamp;
                document.getElementById('packetLossTime').textContent = timestamp;
                
                // Update progress bars (simulated)
                updateProgressBars(data);
                
                // Update status
                updateStatus('{{ t.data_updated }}', 'success');
            }
        } catch (error) {
            console.error('Error fetching current metrics:', error);
            updateStatus('{{ t.error_fetching_metrics }}', 'danger');
        }
    }
    
    // Update progress bars based on thresholds
    function updateProgressBars(data) {
        // Simulated thresholds - in a real app these would come from config
        const downloadThreshold = 100; // Mbps
        const uploadThreshold = 20;    // Mbps
        const pingThreshold = 50;      // ms
        const packetLossThreshold = 5; // %
        
        // Calculate percentages
        const downloadPercent = Math.min(100, (data.download_mbps / downloadThreshold) * 100);
        const uploadPercent = Math.min(100, (data.upload_mbps / uploadThreshold) * 100);
        const pingPercent = Math.min(100, (data.ping_ms / pingThreshold) * 100);
        const packetLossPercent = Math.min(100, (data.packet_loss_percent / packetLossThreshold) * 100);
        
        // Update progress bars
        document.getElementById('downloadProgress').style.width = downloadPercent + '%';
        document.getElementById('uploadProgress').style.width = uploadPercent + '%';
        document.getElementById('pingProgress').style.width = pingPercent + '%';
        document.getElementById('packetLossProgress').style.width = packetLossPercent + '%';
        
        // Update colors based on performance
        updateProgressBarColor('downloadProgress', downloadPercent);
        updateProgressBarColor('uploadProgress', uploadPercent);
        updateProgressBarColor('pingProgress', pingPercent);
        updateProgressBarColor('packetLossProgress', packetLossPercent);
    }
    
    // Update progress bar color based on percentage
    function updateProgressBarColor(elementId, percent) {
        const progressBar = document.getElementById(elementId);
        progressBar.classList.remove('bg-success', 'bg-warning', 'bg-danger');
        
        if (percent < 50) {
            progressBar.classList.add('bg-success');
        } else if (percent < 80) {
            progressBar.classList.add('bg-warning');
        } else {
            progressBar.classList.add('bg-danger');
        }
    }
    
    // Function to update charts
    async function updateCharts() {
        try {
            const response = await axios.get(`/api/metrics?hours=${currentHours}`);
            const data = response.data.data;
            
            if (data && data.length > 0) {
                // Convert data for Chart.js
                const timestamps = data.map(item => new Date(item.timestamp).toLocaleTimeString());
                const downloadSpeeds = data.map(item => item.download_mbps);
                const uploadSpeeds = data.map(item => item.upload_mbps);
                const pingTimes = data.map(item => item.ping_ms);
                const packetLoss = data.map(item => item.packet_loss_percent);
                
                // Destroy existing charts if they exist
                if (performanceChart) performanceChart.destroy();
                if (pingChart) pingChart.destroy();
                if (packetLossChart) packetLossChart.destroy();
                if (downloadDistributionChart) downloadDistributionChart.destroy();
                if (summaryChart) summaryChart.destroy();
                
                // Create new charts
                createPerformanceChart(timestamps, downloadSpeeds, uploadSpeeds);
                createPingChart(timestamps, pingTimes);
                createPacketLossChart(timestamps, packetLoss);
                createDownloadDistributionChart(downloadSpeeds);
                createSummaryChart(downloadSpeeds, uploadSpeeds, pingTimes, packetLoss);
                
                updateStatus('{{ t.data_updated }}', 'success');
            } else {
                updateStatus('{{ t.no_data_time_range }}', 'warning');
            }
        } catch (error) {
            console.error('Error fetching chart data:', error);
            updateStatus('{{ t.error_fetching_chart }}', 'danger');
        }
    }
    
    // Create performance chart
    function createPerformanceChart(timestamps, downloadSpeeds, uploadSpeeds) {
        const ctx = document.getElementById('performanceChart').getContext('2d');
        
        const chartConfig = {
            type: chartType === 'bar' ? 'bar' : chartType === 'area' ? 'line' : 'line',
            data: {
                labels: timestamps,
                datasets: [{
                    label: '{{ t.download_speed }} (Mbps)',
                    data: downloadSpeeds,
                    borderColor: 'rgb(13, 110, 253)',
                    backgroundColor: chartType === 'area' ? 'rgba(13, 110, 253, 0.1)' : 'transparent',
                    tension: chartType === 'line' || chartType === 'area' ? 0.3 : 0,
                    fill: chartType === 'area',
                    pointRadius: 3,
                    pointHoverRadius: 6
                }, {
                    label: '{{ t.upload_speed }} (Mbps)',
                    data: uploadSpeeds,
                    borderColor: 'rgb(25, 135, 84)',
                    backgroundColor: chartType === 'area' ? 'rgba(25, 135, 84, 0.1)' : 'transparent',
                    tension: chartType === 'line' || chartType === 'area' ? 0.3 : 0,
                    fill: chartType === 'area',
                    pointRadius: 3,
                    pointHoverRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            pointStyle: 'circle'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        padding: 12,
                        titleFont: {
                            size: 14
                        },
                        bodyFont: {
                            size: 13
                        }
                    }
                }
            }
        };
        
        performanceChart = new Chart(ctx, chartConfig);
    }
    
    // Create ping chart
    function createPingChart(timestamps, pingTimes) {
        const ctx = document.getElementById('pingChart').getContext('2d');
        
        const chartConfig = {
            type: chartType === 'bar' ? 'bar' : chartType === 'area' ? 'line' : 'line',
            data: {
                labels: timestamps,
                datasets: [{
                    label: '{{ t.ping }} (ms)',
                    data: pingTimes,
                    borderColor: 'rgb(13, 202, 240)',
                    backgroundColor: chartType === 'area' ? 'rgba(13, 202, 240, 0.1)' : 'transparent',
                    tension: chartType === 'line' || chartType === 'area' ? 0.3 : 0,
                    fill: chartType === 'area',
                    pointRadius: 3,
                    pointHoverRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            pointStyle: 'circle'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        padding: 12
                    }
                }
            }
        };
        
        pingChart = new Chart(ctx, chartConfig);
    }
    
    // Create packet loss chart
    function createPacketLossChart(timestamps, packetLoss) {
        const ctx = document.getElementById('packetLossChart').getContext('2d');
        
        const chartConfig = {
            type: chartType === 'bar' ? 'bar' : chartType === 'area' ? 'line' : 'line',
            data: {
                labels: timestamps,
                datasets: [{
                    label: '{{ t.packet_loss }} (%)',
                    data: packetLoss,
                    borderColor: 'rgb(255, 193, 7)',
                    backgroundColor: chartType === 'area' ? 'rgba(255, 193, 7, 0.1)' : 'transparent',
                    tension: chartType === 'line' || chartType === 'area' ? 0.3 : 0,
                    fill: chartType === 'area',
                    pointRadius: 3,
                    pointHoverRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            pointStyle: 'circle'
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        padding: 12
                    }
                }
            }
        };
        
        packetLossChart = new Chart(ctx, chartConfig);
    }
    
    // Create download distribution chart
    function createDownloadDistributionChart(downloadSpeeds) {
        const ctx = document.getElementById('downloadDistribution').getContext('2d');
        const downloadBins = Array(10).fill(0);
        const maxDownload = Math.max(...downloadSpeeds);
        const minDownload = Math.min(...downloadSpeeds);
        const range = maxDownload - minDownload;
        const binSize = range / 10;
        
        downloadSpeeds.forEach(speed => {
            if (binSize > 0) {
                const binIndex = Math.min(Math.floor((speed - minDownload) / binSize), 9);
                downloadBins[binIndex]++;
            } else {
                downloadBins[0]++;
            }
        });
        
        const binLabels = Array.from({length: 10}, (_, i) => {
            const start = minDownload + (i * binSize);
            const end = minDownload + ((i + 1) * binSize);
            return `${start.toFixed(0)}-${end.toFixed(0)} Mbps`;
        });
        
        const chartConfig = {
            type: 'bar',
            data: {
                labels: binLabels,
                datasets: [{
                    label: '{{ t.frequency }}',
                    data: downloadBins,
                    backgroundColor: 'rgba(13, 110, 253, 0.7)',
                    borderColor: 'rgb(13, 110, 253)',
                    borderWidth: 1,
                    borderRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        };
        
        downloadDistributionChart = new Chart(ctx, chartConfig);
    }
    
    // Create summary chart
    function createSummaryChart(downloadSpeeds, uploadSpeeds, pingTimes, packetLoss) {
        const ctx = document.getElementById('summaryChart').getContext('2d');
        
        // Calculate averages
        const avgDownload = downloadSpeeds.reduce((a, b) => a + b, 0) / downloadSpeeds.length;
        const avgUpload = uploadSpeeds.reduce((a, b) => a + b, 0) / uploadSpeeds.length;
        const avgPing = pingTimes.reduce((a, b) => a + b, 0) / pingTimes.length;
        const avgPacketLoss = packetLoss.reduce((a, b) => a + b, 0) / packetLoss.length;
        
        const chartConfig = {
            type: 'radar',
            data: {
                labels: ['{{ t.download_speed }} (Mbps)', '{{ t.upload_speed }} (Mbps)', '{{ t.ping }} (ms)', '{{ t.packet_loss }} (%)'],
                datasets: [{
                    label: '{{ t.performance_metrics }}',
                    data: [avgDownload, avgUpload, avgPing, avgPacketLoss],
                    fill: true,
                    backgroundColor: 'rgba(13, 110, 253, 0.2)',
                    borderColor: 'rgb(13, 110, 253)',
                    pointBackgroundColor: 'rgb(13, 110, 253)',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: 'rgb(13, 110, 253)',
                    pointRadius: 4,
                    pointHoverRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: {
                            display: true,
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        suggestedMin: 0,
                        suggestedMax: 100,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        },
                        pointLabels: {
                            font: {
                                size: 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            pointStyle: 'circle'
                        }
                    }
                }
            }
        };
        
        summaryChart = new Chart(ctx, chartConfig);
    }
    
    // Update time range
    function updateTimeRange(hours, label) {
        currentHours = hours;
        document.getElementById('timeRangeDropdown').textContent = label;
        updateCharts();
    }
    
    // Toggle auto refresh
    function toggleAutoRefresh() {
        const btn = document.getElementById('autoRefreshBtn');
        const isActive = btn.getAttribute('data-active') === 'true';
        
        if (isActive) {
            // Disable auto refresh
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
            btn.innerHTML = '<i class="fas fa-play"></i> {{ t.auto_refresh }}';
            btn.setAttribute('data-active', 'false');
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-outline-secondary');
        } else {
            // Enable auto refresh
            autoRefreshInterval = setInterval(() => {
                updateCurrentMetrics();
                updateCharts();
            }, 30000); // Refresh every 30 seconds
            btn.innerHTML = '<i class="fas fa-pause"></i> {{ t.auto_refresh }}';
            btn.setAttribute('data-active', 'true');
            btn.classList.remove('btn-outline-secondary');
            btn.classList.add('btn-outline-primary');
        }
    }
    
    // Change chart type
    function changeChartType(type) {
        chartType = type;
        
        // Update button states
        document.getElementById('chartTypeLine').classList.remove('active');
        document.getElementById('chartTypeBar').classList.remove('active');
        document.getElementById('chartTypeArea').classList.remove('active');
        
        switch(type) {
            case 'line':
                document.getElementById('chartTypeLine').classList.add('active');
                break;
            case 'bar':
                document.getElementById('chartTypeBar').classList.add('active');
                break;
            case 'area':
                document.getElementById('chartTypeArea').classList.add('active');
                break;
        }
        
        // Update charts
        updateCharts();
    }
    
    // Update weather correlation table
    async function updateWeatherCorrelations() {
        try {
            const response = await axios.get('/api/weather-correlations');
            const data = response.data;
            
            const tableBody = document.getElementById('weatherCorrelationTableBody');
            
            if (data && data.interpreted_correlations) {
                // Clear existing rows
                tableBody.innerHTML = '';
                
                // Add new rows
                for (const [weatherParam, perfCorrelations] of Object.entries(data.interpreted_correlations)) {
                    for (const [perfParam, details] of Object.entries(perfCorrelations)) {
                        const row = document.createElement('tr');
                        
                        // Determine correlation strength class
                        let strengthClass = '';
                        if (details.correlation >= 0.7 || details.correlation <= -0.7) {
                            strengthClass = 'table-danger';
                        } else if (details.correlation >= 0.5 || details.correlation <= -0.5) {
                            strengthClass = 'table-warning';
                        } else if (details.correlation >= 0.3 || details.correlation <= -0.3) {
                            strengthClass = 'table-info';
                        }
                        
                        row.className = strengthClass;
                        
                        row.innerHTML = `
                            <td>${weatherParam}</td>
                            <td>${perfParam}</td>
                            <td>${details.correlation.toFixed(3)}</td>
                            <td>${details.strength}</td>
                            <td>${details.interpretation}</td>
                        `;
                        
                        tableBody.appendChild(row);
                    }
                }
                
                if (tableBody.children.length === 0) {
                    tableBody.innerHTML = '<tr><td colspan="5" class="text-center">{{ t.no_correlation_data }}</td></tr>';
                }
            } else {
                tableBody.innerHTML = '<tr><td colspan="5" class="text-center">{{ t.no_correlation_data }}</td></tr>';
            }
        } catch (error) {
            console.error('Error fetching weather correlations:', error);
            const tableBody = document.getElementById('weatherCorrelationTableBody');
            tableBody.innerHTML = '<tr><td colspan="5" class="text-center">{{ t.error_loading_data }}</td></tr>';
        }
    }
    
    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize WebSocket
        initWebSocket();
        
        // Initial data load
        updateCurrentMetrics();
        updateCharts();
        updateWeatherCorrelations();
        
        // Set up refresh button
        document.getElementById('refreshBtn').addEventListener('click', function() {
            updateCurrentMetrics();
            updateCharts();
            updateWeatherCorrelations();
        });
        
        // Set up auto refresh button
        document.getElementById('autoRefreshBtn').addEventListener('click', function() {
            toggleAutoRefresh();
        });
        
        // Set up time range menu
        document.querySelectorAll('#timeRangeMenu .dropdown-item').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
                const hours = parseInt(this.getAttribute('data-hours'));
                const label = this.textContent;
                updateTimeRange(hours, label);
                
                // Update active state
                document.querySelectorAll('#timeRangeMenu .dropdown-item').forEach(i => {
                    i.classList.remove('active');
                });
                this.classList.add('active');
            });
        });
        
        // Set up chart type buttons
        document.getElementById('chartTypeLine').addEventListener('click', function() {
            changeChartType('line');
        });
        document.getElementById('chartTypeBar').addEventListener('click', function() {
            changeChartType('bar');
        });
        document.getElementById('chartTypeArea').addEventListener('click', function() {
            changeChartType('area');
        });
        
        // Set initial chart type button state
        document.getElementById('chartTypeLine').classList.add('active');
        
        // Start auto refresh
        autoRefreshInterval = setInterval(() => {
            updateCurrentMetrics();
            updateWeatherCorrelations();
        }, 30000); // Refresh every 30 seconds
    });
</script>
{% endblock %}